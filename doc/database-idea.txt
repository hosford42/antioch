# antioch
# Copyright (c) 1999-2010 Phil Christensen
#
# $Id$
#
# See LICENSE for details

the solution to the database vs. antioch issue may lie in a combination of using PostgreSQL in combination with t.e.adbapi's runInteraction method. The interaction would be used to spawn any interaction with the database, including login/logout housekeeping, parsing command statements, and particularly in issuing verb calls.

this allows entity code to remain entirely synchronous, both in verbs and in actual entity methods.

additionally, the use of transactions in Postgres not only ensures that we can treat various events as atomic changes to the 'world', but may also improve the possibility of running untrusted code...

since no verb code would issue direct SQL, it would be important for a verb to finish, so that 'COMMIT;' could be called. this creates less incentive to create an infinite loop in verb code. it should also be possible to create administrative threads that used postgres calls to watch the status of connections being used by verb code. 

since verb code is not generally needed to be long-running, it may be possible to programmatically detect a malevolent verb by the number of database calls it makes, or limit certain authors or users to a certain number of calls per verb (like lambdamoo does, i believe), or a total script runtime (like javascript).

if a thread is misbehaving, it could be killed from the database side, thus voiding the transaction and negating any database changes. the next action that resulted in a call to the database would throw an exception.

of course, this still doesn't prevent a determined attacker, who could just do the 'ole:

  l = []
  while(True):
    l.append(True)

and that can even happen by mistake. however, once all changes to the universe are happening through calls to the database, it may be possible to fork a child process to open the connection to the db, and run the verb code inside that. then general unix process limitations could be enforced.

investigate twisted ampoule, or whatever that thing was they were doing with subprocesses. that probably makes this like 10 lines of code ;-)

my plan is to allow deferred verb calls, that will run code at a later time with whatever are the appropriate privileges. to prevent a determined or stupid programmer from creating a slightly slower version of the above code, antioch should treat verb code as queue of one or more pieces of code. even though the database would be updated after each piece ran, they would be adding to a total score for the original caller.

it may also be possible to use postgres metrics of some kind to determine how much data or rows are changed in the transaction each chunk of code commits, thus adding to another total.

this provides a great incentive to learn postgres, and will likely reveal a wealth of information about using it.